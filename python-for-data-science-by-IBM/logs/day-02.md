📅 July 12, 2025  
## 📦 Module 3: Python Data Structures – Conditions & Branching, Loops, Functions  

### 📚 Topics Covered  
#### ✅ Conditions & Branching  
- Comparison operators: `==`, `!=`, `>`, `<`, `>=`, `<=`  
- Boolean logic: `and`, `or`, `not`  
- `if`, `elif`, `else` statements  
- Writing conditional blocks to control program flow  
- Nesting conditionals  

#### 🔁 Loops  
- `for` loops for iterating over sequences (lists, strings, etc.)  
- `while` loops for conditional repetition  
- `break`, `continue`, and `pass` statements  
- Looping through dictionaries with `.items()`  
- Enumerated loops using `enumerate()`  
- Nested loops  

#### 🧩 Functions  
- Defining functions using `def`  
- Function parameters and return values  
- Using `return` to output results  
- Variable scope (local vs global)  
- Default argument values  
- Using functions to reduce code duplication and increase readability  

---

### 🧠 Key Concepts  
#### Conditions & Branching  
- Conditional logic allows the program to make decisions dynamically.  
- Boolean expressions and logical operators help combine multiple checks.  
- Nested conditions can handle complex decision trees.  

#### Loops  
- Loops automate repetitive tasks.  
- `for` loops are ideal when iterating over known sequences.  
- `while` loops are useful when the end condition isn't based on a sequence.  
- `break` and `continue` add control inside loops to exit or skip iterations.  
- The `enumerate()` function allows tracking both the index and value when iterating, which is helpful for debugging or referencing positions.

🔄 Loop Flow Pattern:
1. Initialization – Set up starting conditions or counters.
2. Condition – Decide when to stop looping.
3. Execution – Perform tasks inside the loop.
4. Update – Change conditions to move forward.
5. Repeat – Return to the condition check until it fails.

⏳ When to Use Each Type:
- for loops: Ideal when the number of iterations is known or when processing items in a collection.
- while loops: Best when repeating a task until a condition is met, especially when the number of iterations isn’t known in advance.

#### Functions  
- Functions encapsulate logic for reuse, improving code clarity.  
- Parameters and return values make functions flexible and modular.  
- Understanding scope helps manage variable visibility and debugging.  

---
